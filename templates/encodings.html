{% extends "layout.html" %}

{% block title %}
  Encodings
{% endblock %}

{% block main %}
  <div class="row" style="display: flex; justify-content: center;">
    <div class="col-4" id="scrollspy">
      <nav class="h-100 flex-column align-items-stretch pe-4 border-end" style="position: fixed;">
        <nav class="nav nav-pills flex-column" style="text-align: left;">
          <a class="nav-link" href="#encoding-1">Alphabets</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ms-3 my-1" href="#encoding-1-1">Morse Code</a>
            <a class="nav-link ms-3 my-1" href="#encoding-1-2">Spelling Alphabet</a>
          </nav>
          <a class="nav-link" href="#encoding-2">Ciphers</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ms-3 my-1" href="#encoding-2-1">Caesar Cipher</a>
          </nav>
          <a class="nav-link" href="#encoding-3">Encodings</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ms-3 my-1" href="#encoding-3-1">Base32</a>
          </nav>
        </nav>
      </nav>
    </div>

    <div class="col-8">
      <div>
        <div id="encoding-1">
          <h3>Alphabets</h3>
          <p class="lh-sm" style="text-align: justify;">
            Alphabet Encoding, also known as Character Encoding or Symbolic Encoding, is a method for representing characters, symbols, or texts using a systematic set of symbols or codes. Some common examples of Alphabet Encoding are Morse Code and the NATO phonetic alphabet (spelling alphabet).
          </p>
          <p class="lh-sm" style="text-align: justify;">
            Strictly speaking, Alphabet Encoding is formalized as a cryptography containing:
          </p>
          <ul style="text-align: justify;">
            <li>A finite set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> of characters or symbols that will be encrypted</li>
            <li>A finite set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math> of cryptographic characters that will be used to represent all symbols in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></li>
            <li>An encoding function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>Σ</mi><mo>→</mo><msup><mi>V</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\sigma : \Sigma \to V^*</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> is the Kleene Star, a unary operator applied to a set of strings that, intuitively, represents all the strings formed by the symbols in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>, including the empty string <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>, or also the smallest superset of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math> that contains the empty string <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math> and is closed under the concatenation operation. Formally we can define it recursively as:</li>
          </ul>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msup><mi>V</mi><mn>0</mn></msup></mtd><mtd columnalign="left" style="text-align: left"><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><mi>ε</mi><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msup><mi>V</mi><mn>1</mn></msup></mtd><mtd columnalign="left" style="text-align: left"><mo>:=</mo><mi>V</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msup><mi>V</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup></mtd><mtd columnalign="left" style="text-align: left"><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mi>v</mi><mo>∣</mo><mi>w</mi><mo>∈</mo><msup><mi>V</mi><mi>i</mi></msup><mo>∧</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
            V^0 &amp; := \{\varepsilon\}\\
            V^1 &amp; := V\\
            V^{i + 1} &amp; := \{wv \mid w \in V^i \wedge v \in V\}
          \end{aligned}</annotation></semantics></math>
          <p class="lh-sm" style="text-align: justify;">
            Therefore
          </p>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>*</mo><mo>:=</mo><munder><mo>⋃</mo><mrow><mi>i</mi><mo>≥</mo><mn>0</mn></mrow></munder><msup><mi>V</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">V* := \bigcup_{i\geq 0} V^i</annotation></semantics></math>
          <p class="lh-sm" style="text-align: justify;">
            The encrypted representation of a code formed by the symbols in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> is the replacement of each symbol in the string by its respective value applied to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>, for example, if our code is the string <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><msub><mi>α</mi><mn>1</mn></msub><msub><mi>α</mi><mn>2</mn></msub><mi>…</mi><msub><mi>α</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\alpha = \alpha_1\alpha_2\dots\alpha_n</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub><mo>∈</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\alpha_i \in \Sigma</annotation></semantics></math>, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq i \leq n</annotation></semantics></math>, then the encrypted representation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>, denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma(\alpha)</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>…</mi><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma(\alpha_1)\sigma(\alpha_2)\dots\sigma(\alpha_n)</annotation></semantics></math>. 
          </p>
        </div>
        <div id="encoding-1-1">
          <h5>Morse Code</h5>
          <p class="lh-sm" style="text-align: justify;">
            From the formalization above, we can define Morse Code as follows:
          </p>
          <ul style="text-align: justify;">
            <li>The alphabet <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> consists of the 26 letters of the English alphabet (A-Z), the Arabic numerals (0-9), and a set of special characters (e.g., punctuation marks and prosigns).</li>
            <li>The Morse Code uses three symbols, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mtext mathvariant="normal">&quot;.&quot;</mtext><mo>,</mo><mtext mathvariant="normal">&quot;-&quot;</mtext><mo>,</mo><mtext mathvariant="normal">&quot;/&quot;</mtext><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">V = \{\text{&quot;.&quot;}, \text{&quot;-&quot;}, \text{&quot;/&quot;}\}</annotation></semantics></math>, where the dot <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(.)</annotation></semantics></math> represents a short signal, as a unit of time, and the dash <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(-)</annotation></semantics></math> a long signal, typically three times the duration of a dot, and the bar <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>/</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(/)</annotation></semantics></math> is for space.</li>
            <li>And the Morse Code encoding function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is defined as the table:</li>
          </ul>
          <img src="static/Morse_Code_Chart.png" alt="Morse Code Conversion Table" width="528" height="408" style="vertical-align: auto;">
          <p class="lh-sm" style="text-align: justify;">
            Along with some additional characters you can test in <a href="https://cryptii.com">cryptii</a>, like the space being "/".
          </p>
        </div>
        <div id="encoding-1-2">
          <h5>Spelling Alphabet</h5>
          <p class="lh-sm" style="text-align: justify;">
            Again by formalizing Alphabet Encoding, we can define Spelling Alphabet (also known as NATO phonetic alphabet) as:
          </p>
          <ul style="text-align: justify;">
            <li>The alphabet <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> consists of the 26 letters of the English alphabet (A-Z).</li>
            <li>The Spelling Alphabet uses the same symbols as the alphabet, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">V = \Sigma</annotation></semantics></math> (There are some variations between upper and lower case, but the principle is the same).</li>
            <li>And the Spelling Alphabet encoding function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is defined as the table:</li>
          </ul>
          <img src="static/NATO.jpg" alt="Spelling Alphabet Conversion Table" width="400" height="517.6" style="vertical-align: auto;">
          <p class="lh-sm" style="text-align: justify;">
            Again, you can test encoding and decoding in <a href="https://cryptii.com">cryptii</a>.
          </p>
        </div>
        <div id="encoding-2">
          <h3>Ciphers</h3>
          <p class="lh-sm" style="text-align: justify;">
            Ciphers are much more general categories than alphabet ciphers that use substitution; they are, in general, defined by their use. Ciphers are intended to send or store information securely, therefore, in general, the encryption of a given input is determined by certain factors called keys. These guarantee that, if someone tries to decrypt the encrypted message by brute force, it will take an extremely long time without the key, making knowledge of the information practically restricted to those who know the key. Some famous examples are: Caesar Cipher, Enigma Machine, Vigenère Cipher, A1Z26, etc.
          </p>
        </div>
        <div id="encoding-2-1">
          <h5>Caesar Cipher</h5>
          <p class="lh-sm" style="text-align: justify;">
            The Caesar cipher is an extremely well-known and very common cipher, it is often used as one of the first examples of cryptography, as it is easy to understand and can be easily decrypted by brute force. Originally, in general, the cipher is used in relation to the usual alphabet <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>Z</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{A, B, ..., Z\}</annotation></semantics></math>, but it can be used for any set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> of finite characters.
          </p>
          <p class="lh-sm" style="text-align: justify;">
            Therefore, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> is a set of arbitrary characters, we define an enumeration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x_1, x_2, ..., x_n)</annotation></semantics></math> of its characters and define the bijection <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>Σ</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\sigma : \Sigma \to \{0, 1, ..., n-1\}</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sigma(x_i) := i - 1</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq i &lt; n</annotation></semantics></math>. Thus, we have a coding function for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, i.e., there are different coding functions for the Caesar Cipher depending on the ordering of the characters in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> and the number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> chosen. Thus, to define the coding function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>k</mi></msub><annotation encoding="application/x-tex">E_k</annotation></semantics></math>, we first define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>k</mi></msub><mi>′</mi><mo>:</mo><mi>Σ</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\sigma_k&#39; : \Sigma \to \{0, 1, ..., n-1\}</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>k</mi></msub><mi>′</mi><mo>:=</mo><msub><mi>τ</mi><mi>k</mi></msub><mo>∘</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma_k&#39; := \tau_k\circ\sigma</annotation></semantics></math>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>
             being the previously defined function and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\tau_k</annotation></semantics></math> being an automorphism in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, ..., n-1\}</annotation></semantics></math> and defined as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> mod </mtext><mspace width="0.333em"></mspace></mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">\tau_k(x) := (x + k)\text{ mod }n</annotation></semantics></math>. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is bijective, there is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo>→</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\sigma^{-1} : \{0, 1, ..., n-1\} \to \Sigma</annotation></semantics></math>, therefore we can define the bijection <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>k</mi></msub><mo>:</mo><msup><mi>σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∘</mo><msub><mi>σ</mi><mi>k</mi></msub><mi>′</mi></mrow><annotation encoding="application/x-tex">\sigma_k : \sigma^{-1}\circ\sigma_k&#39;</annotation></semantics></math>. With this, the coding function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>k</mi></msub><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">E_k : \Sigma^* \to \Sigma^*</annotation></semantics></math>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> being the Kleene star, as defined in the Alphabets formalization, is such that for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><msub><mi>α</mi><mn>1</mn></msub><msub><mi>α</mi><mn>2</mn></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>α</mi><mi>m</mi></msub><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\alpha = \alpha_1\alpha_2...\alpha_m \in \Sigma^*</annotation></semantics></math>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub><mo>∈</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\alpha_i \in \Sigma</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq i\leq m</annotation></semantics></math>,
             we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mi>σ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>σ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>σ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>m</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">E_k(\alpha) := \sigma_k(\alpha_1)\sigma_k(\alpha_2)...\sigma_k(\alpha_m)</annotation></semantics></math>. In the case of the Caesar Cipher, it is also easy to define a decoding function, just take <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>σ</mi><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><annotation encoding="application/x-tex">\sigma_k^{-1}</annotation></semantics></math>, which exists since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\sigma_k</annotation></semantics></math> is bijective, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>E</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>σ</mi><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi><mi>.</mi><mi>.</mi><msubsup><mi>σ</mi><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>m</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">D_k(E_k(\alpha)) = \sigma_k^{-1}(\sigma_k(\alpha_1))...\sigma_k^{-1}(\sigma_k(\alpha_m)) = \alpha</annotation></semantics></math>.
          </p>
        </div>
        <div id="encoding-3">
          <h3>Encodings</h3>
          <p class="lh-sm" style="text-align: justify;">
            Unlike ciphers, encodings are a type of cipher whose key, or conversion table, is public knowledge and whose purpose is not necessarily the security of data and information, therefore, just like ciphers, encodings are categorized by their purpose rather than its functioning. Some famous examples are: Base32, Base64, ASCII, URL encoding, etc.
          </p>
        </div>
        <div id="encoding-3-1">
          <h5>Base32</h5>
          <p class="lh-sm" style="text-align: justify;">
            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Enim nesciunt accusamus, veritatis illo voluptatem repellat consequatur id aliquam commodi! Cumque repellendus reprehenderit temporibus vitae, exercitationem vero iusto alias ullam omnis.
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam enim officia voluptas dolores quidem doloribus veritatis, mollitia incidunt nihil sapiente veniam expedita totam, fugit, eaque quam odit velit rem vitae.
          </p>
          <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC4648 TABLE</a>
          <!-- https://www.youtube.com/watch?v=Va8FLD-iuTg -->
        </div>
      </div>
    </div>
  </div>

  <style>
    /* Default styles for #scrollspy */
    #scrollspy {
      display: none; /* Displayed by default */
    }

    /* Media query for screens with a minimum width of 768px */
    @media (min-width: 768px) and (min-height: 500px) {
      #scrollspy {
        display: block; /* Hide #scrollspy on screens >= 768px */
      }
    }
  </style>
  

  <script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <!--LaTeX formatting done at: https://pandoc.org/try/
      \begin{equation}
        <LaTeX Code>
      \end{equation}
    -->
{% endblock %}